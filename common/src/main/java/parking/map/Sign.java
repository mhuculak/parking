package parking.map;

import parking.schedule.ParkingSchedule;
import parking.map.Address;
import parking.util.Logger;
import parking.util.LoggingTag;
import parking.util.Exif;
import parking.util.Utils;

import com.mongodb.gridfs.GridFSDBFile;

import java.util.Collections;
import java.util.Comparator;

import java.io.File;
import java.util.Random;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Date;

public class Sign {
	
	private String id;
	private Date tstamp;
	private Position position;
	private String imageName;
	private ParkingSchedule autoSchedule;  // schedule generated by image processing
	private ParkingSchedule schedule;      // verified schedule
	private int updates;
//	private Address address;
	private Logger m_logger;

	public Sign(File signPicture, Logger logger) {
		m_logger = new Logger( logger, this, LoggingTag.Map);
		position = processSignImage(signPicture);
		if (position == null) {
			m_logger.error("new sign has no position");
		}
	}

	public Sign(GridFSDBFile signPicture, Logger logger) {
		m_logger = new Logger( logger, this, LoggingTag.Map);
		position = Exif.getPosition(signPicture.getInputStream());
		imageName = signPicture.getFilename();
	}

	public Sign(File signPicture, Position position, Logger logger) {
		m_logger = new Logger( logger, this, LoggingTag.Map);
		this.position = position;
		m_logger = logger;		
	}

	public Sign(String id, Position p, String imageName, Logger logger) {
		m_logger = new Logger( logger, this, LoggingTag.Map);
		this.id = id;
		position = p;
		this.imageName = imageName;
	}

	public void setTimeStamp(Date tstamp) {
		this.tstamp = tstamp;
	}

	public void setPosition(Position p) {
		position = p;
	}

	public void setUpdates(int updates) {
		this.updates = updates;
	}

	public void setParkingSchedule(ParkingSchedule sched) {
		schedule = sched;
	}

	public void setAutoSchedule(ParkingSchedule schedule) {
		autoSchedule = schedule;
	}

	public boolean updatePosition(Map<String, String> postData) {		
		String streetName = postData.get("street");
		String streetNum = postData.get("streetNumber");
		StringBuilder sb = new StringBuilder(10);
		sb.append(streetNum+" "+streetName);
		if (postData.get("city") != null) {
			sb.append(" "+postData.get("city"));
		}
		if (postData.get("zip") != null) {
			sb.append(" "+postData.get("zip"));
		}
		String place = sb.toString();
		Position newPosition = Position.getLocation(place, null, 0.0);
		if (newPosition != null) {			
				position = newPosition;
				return true;
		}
		m_logger.error("Failed to get position for "+place);
		return false;
	}

	public String getID() {
		return id;
	}

	public Position getPosition() {
		return position;
	}

	public Address getAddress() {
		if (position != null) {
			return Address.reverseGeocode(position);
		}
		return null;
	}

	public String getImageName() {
		return imageName;
	}

	public int getUpdates() {
		return updates;
	}

	public Date getTimeStamp() {
		return tstamp;
	}

	public String displayText() {
		StringBuilder sb = new StringBuilder(10);
		if (schedule != null) {
			sb.append(schedule.displayText());
		}
		else if (autoSchedule != null) {
			sb.append(autoSchedule.displayText());
		}
		else {
			sb.append("<p><b>ERROR:</b>no schedule found</p><br>");
		}
		if (position != null) {
			Address address = Address.reverseGeocode(position);
			if (address != null) {
				sb.append(address.displayText());
			}
//			sb.append("<p>"+position.toString()+"</p><br>");
		}
		else {
			sb.append("<p><b>ERROR:</b>no position found</p>");
		}
		
		return sb.toString();
	}

	public String toString() {
		StringBuilder sb = new StringBuilder(10);
		sb.append("id = "+id);
		if (imageName != null) {
			sb.append(" image = "+imageName);
		}
		else {
			sb.append(" image = null");
		}
		if (position != null) {
//			Address address = reverseGeocode(position, m_logger);
//			sb.append(" "+address.displayText());
			sb.append(position.toString());
		}
		else {
			sb.append(" position = null");
		}
		if (schedule != null) {
			sb.append(" "+schedule.toString());
		}
		if (autoSchedule != null) {
			sb.append(" "+autoSchedule.toString());
		}
		return sb.toString();
	}

	public ParkingSchedule getParkingSchedule() {
		return schedule;
	}

	public ParkingSchedule getAutoSchedule() {
		return autoSchedule;
	}

	private  Position processSignImage(File signPicture) {
		return Exif.getPosition(signPicture);
	}

	public static String createRandom(int len) {
		final String alphabet = "0123456789ABCDE";
    	final int N = alphabet.length();

    	Random r = new Random();
    	StringBuilder sb = new StringBuilder(len);
    	for (int i = 0; i < len; i++) {
        	sb.append(alphabet.charAt(r.nextInt(N)));
    	}
    	return sb.toString();
	}

	//
	//  Resolve position of sign based on the following data uploaded from the
	//  phone used to take the sign picture:
	//
	//   a) addressString - address entered by the user on the sign schedule verification form
	//   b) trajectory - position and time history of the user's phone
	//
	//      Note: the last item in the history corresponds to when the picture was taken
	//
	public static Position resolvePosition(String addressString, Trajectory trajectory, double startTime, double endTime) {
		Logger logger = new Logger( LoggingTag.Map, "Sign", "resolvePosition");
		final double minDesiredAccuracy = 20.0;
//		String streetFromTrajectory = getStreetFromTrajectory(trajectory, logger);
		Position mostAccurate = getMostAccuratePosition(trajectory, startTime, endTime, logger);
		Position posFromAddress = Position.getLocation(addressString, null, 0);
//		Address address = posFromAddress == null ? null : Address.reverseGeocode(posFromAddress);		
		if (posFromAddress != null && mostAccurate != null) {
			double dist = 1000*Position.getDistanceKm(posFromAddress, mostAccurate);
			boolean correlate = true;
			if (dist < mostAccurate.getAccuracy()) {
				logger.log("position from address correlates with selected position dist = "+dist+" "+mostAccurate.getAccuracy());
				correlate = true;
			}
			else {
				logger.log("position from address does not correlate with selected position dist = "+dist+" "+mostAccurate.getAccuracy());
				correlate = false;
			}
			if (correlate == false || mostAccurate.getAccuracy() < minDesiredAccuracy) {
				logger.log("Using most accurate position");
				return mostAccurate;
			}
			else {
				return posFromAddress;
			}
		}
		else if (posFromAddress != null) {
			return posFromAddress;
		}
		else {
			return mostAccurate;
		}			
	}

	private static String getStreetFromTrajectory(Trajectory trajectory, Logger logger) {
		Map<String, Integer> streetCount = new HashMap<String, Integer>();
		for ( int i=1 ; i<trajectory.getPositions().size() ; i++) {
			Position p = trajectory.getPosition(i);
			Address address = Address.reverseGeocode(p);
			if (address.getStreetName() != null) {
				Integer count = streetCount.get(address.getStreetName());
				if (count == null) {
					streetCount.put(address.getStreetName(), 1);
				}
				else {
					streetCount.put(address.getStreetName(), ++count);
				}
			}
		}
		String bestStreet = null;
		int max = 0;
		for (String street : streetCount.keySet()) {
			if (streetCount.get(street) > max) {
				max = streetCount.get(street);
				bestStreet = street;
			}
		}

		return bestStreet;
	}
	//
	//  Accuracy is measured as the 68% radius in meters so the best accuracy
	//  is the minimum accuracy. The further in time we move from
	//  when the picture was taken, the more accuracy will decrease because
	//  we assume the user is walking at a normal pace
	//  units are meters, seconds
	//
	private static Position getMostAccuratePosition(Trajectory trajectory, double startTime, double endTime, Logger logger) {
		final double normalWalkingSpeed = 1.4;		
		double bestAccuracy = 0.0;
		Position bestPosition = null;
		Position initPos = null;
		if (trajectory == null) {
			return null;
		}
		for ( int i=0 ; i<trajectory.getPositions().size() ; i++) {
			Position p = trajectory.getPosition(i);
			logger.log("position "+i+" "+p.toString()+" time = "+ trajectory.getTime(i));
			double timeDelay = 0.0;			
			if (trajectory.getTime(i) > endTime)  {
				timeDelay = trajectory.getTime(i) - endTime;
			}
			else if (trajectory.getTime(i) < startTime) {
				timeDelay = startTime - trajectory.getTime(i);
			}
			else if (trajectory.getTime(i) == endTime) {
				initPos = p;
			}
			double walkingDist = normalWalkingSpeed*timeDelay;
			double accuracy = p.getAccuracy() + walkingDist;
			logger.log("position "+i+" time delay = "+timeDelay+" accuracy = "+p.getAccuracy()+" walking dist = "+walkingDist+" total = "+accuracy);
			if (bestPosition == null || accuracy < bestAccuracy) {
				bestPosition = p;
				bestAccuracy = accuracy;
			}
		}
		if (initPos != null) {
			double dist =  1000*Position.getDistanceKm(bestPosition, initPos);
			logger.log("best position is "+dist+" meters from camera end position");
		}
		return bestPosition;
	}

	public static List<StreetSegment> findStreetSegments(List<Sign> signs) {
		List<StreetSegment> segments = new ArrayList<StreetSegment>();
		Map<String, List<Sign>> streetMap = new HashMap<String, List<Sign>>();
		Map<Sign, Address> addressMap = new HashMap<Sign, Address>();
		for (Sign sign : signs) {
			Address address = Address.reverseGeocode(sign.getPosition());
			if (address != null) {
				addressMap.put(sign, address);
				String name = address.getStreetName();
				if (name != null) {
					List<Sign> streetList = streetMap.get(name);
					if (streetList == null) {
						streetList = new ArrayList<Sign>();
						streetMap.put(name, streetList);
					}
					streetList.add(sign);					
				}
			}
		}
		for (String address : streetMap.keySet()) {
			List<StreetSegment> segs = findSegmentsFromStreet(address, streetMap.get(address), addressMap);
			if (segs != null) {
				segments.addAll(segs);
			}
		}
		if (segments.size() > 0) {
			return segments;
		}
		return null;
	}

	public static List<StreetSegment> findSegmentsFromStreet(String streetName, List<Sign> signs, 
																Map<Sign, Address> addressMap) {
		Map<Sign, ParkingSchedule> schedules = new HashMap<Sign, ParkingSchedule>();
		List<SignAddress> signAddress = new ArrayList<SignAddress>();
		for (Sign sign : signs) {
			ParkingSchedule schedule = sign.getParkingSchedule() == null ? sign.getAutoSchedule() : sign.getParkingSchedule();
			schedules.put(sign, schedule);
			String streetNumber = addressMap.get(sign).getStreetNumber();
			if (streetNumber != null) {
				SignAddress sa = new SignAddress(sign, streetNumber);
				signAddress.add(sa);
			}
		}
		SignAddressComparator comparator = new SignAddressComparator();
		Collections.sort(signAddress, comparator);
		List<StreetSegment> segments = new ArrayList<StreetSegment>();
		ParkingSchedule even = null;
		ParkingSchedule odd = null;
		List<StreetSegment> missingEven = new ArrayList<StreetSegment>();
		List<StreetSegment> missingOdd = new ArrayList<StreetSegment>();
		StreetSegment currSegment = new StreetSegment(streetName);
		segments.add(currSegment);
		for (SignAddress sa : signAddress) {
			ParkingSchedule schedule = schedules.get(sa.sign);
			if (schedule != null) {
				if (sa.isEven()) {
					if (even == null || !schedule.equals(even)) {					
						even = schedules.get(sa.sign);
						if (currSegment.getScheduleEven() == null) {
							currSegment.setEven(even);
						}
						else {
							if (currSegment.getScheduleOdd() == null) {						
								missingOdd.add(currSegment);
							}
							currSegment = new StreetSegment(streetName);
							currSegment.setEven(even);
							segments.add(currSegment);
						}
					}
					if (missingEven.size() > 0) {
						for (StreetSegment seg : missingEven) {
							seg.setEven(even);
						}
						missingEven.clear();
					}
				}
				else {
					if (odd == null || !schedule.equals(odd)) {
						odd = schedules.get(sa.sign);
						if (currSegment.getScheduleOdd() == null) {
							currSegment.setOdd(odd);
						}
						else {
							if (currSegment.getScheduleEven() == null) {							
								missingEven.add(currSegment);
							}
							currSegment = new StreetSegment(streetName);
							currSegment.setOdd(odd);
							segments.add(currSegment);
						}
					}
					if (missingOdd.size() > 0) {
						for (StreetSegment seg : missingOdd) {
							seg.setOdd(odd);
						}
						missingOdd.clear();
					}
				}
				currSegment.addSign(sa.sign.getID(), sa.sign.getPosition(), schedule);
			}
		}		
		if (segments.size() > 0) {
			return segments;
		}
		return null;
	}

}

class SignAddress {
	public String streetNumber;
	public int value;
	public Sign sign;

	public SignAddress(Sign sign, String streetNumber) {
		this.streetNumber = streetNumber;
		value = Utils.parseInt(streetNumber);
		this.sign = sign;
	}

	public int getValue() {
		return value;
	}

	public boolean isEven() {
		return value % 2 == 0;
	}
}

class SignAddressComparator implements Comparator<SignAddress> {
	@Override
	public int compare(SignAddress s1, SignAddress s2) {
		if (s1.getValue() > s2.getValue()) {
			return -1;
		}
		else if (s1.getValue() < s2.getValue()) {
			return 1;
		}
		else {
			return 0;
		}
	}
}