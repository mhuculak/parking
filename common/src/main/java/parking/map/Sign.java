package parking.map;

import parking.util.Exif;
import parking.schedule.ParkingSchedule;

import parking.util.Logger;
import parking.util.LoggingTag;
import parking.map.Address;

import com.google.maps.GeoApiContext;
import com.google.maps.model.LatLng;
import com.google.maps.GeocodingApi;
import com.google.maps.model.GeocodingResult;

// import com.google.code.geocoder.model.LatLng;
import com.google.code.geocoder.Geocoder;
import com.google.code.geocoder.GeocoderRequestBuilder; 
import com.google.code.geocoder.model.GeocodeResponse; 
import com.google.code.geocoder.model.GeocoderRequest; 
import com.google.code.geocoder.model.GeocoderResult;

import java.io.File;
import java.util.Random;
import java.util.Map;
import java.util.List;

public class Sign {
	
	private String id;
	private Position position;
	private String imageName;
	private ParkingSchedule autoSchedule;  // schedule generated by image processing
	private ParkingSchedule schedule;      // verified schedule
//	private Address address;
	private Logger m_logger;

	public Sign(File signPicture, Logger logger) {
		m_logger = new Logger( logger, this, LoggingTag.Map);
		position = processSignImage(signPicture);
	}

	public Sign(File signPicture, Position position, Logger logger) {
		m_logger = new Logger( logger, this, LoggingTag.Map);
		this.position = position;
		m_logger = logger;		
	}

	public Sign(String id, Position p, String imageName, Logger logger) {
		m_logger = new Logger( logger, this, LoggingTag.Map);
		this.id = id;
		position = p;
		this.imageName = imageName;
	}

/*
	private void getAddressTag(String picName) {
		if (position != null) {
			address = reverseGeocode(position, m_logger);
			if (address != null) {
				String shortAdd = address.getShortAddress();
				String prefix = shortAdd.replace(" ", "_");
				pictureTag = prefix + "_" + createRandom(3) + "_" + picName;
			}
			else {
				m_logger.error("cannot get address from " + position.toString());
			}
		}
		else {
			pictureTag = createRandom(10) + "_" + picName;
		}
	}

	public Sign(String id, Position p, String imageID, Address a, Logger logger) {
		this.id = id;
		position = p;
		pictureTag = imageID;
		address = a;
	}

	public void setDirection(Direction d) {
		direction = d;
	}
*/
	public void setParkingSchedule(ParkingSchedule sched) {
		schedule = sched;
	}

	public void setAutoSchedule(ParkingSchedule schedule) {
		autoSchedule = schedule;
	}

	public boolean updatePosition(Map<String, String> postData) {		
		String streetName = postData.get("street");
		String streetNum = postData.get("streetNumber");
		StringBuilder sb = new StringBuilder(10);
		sb.append(streetNum+" "+streetName);
		if (postData.get("city") != null) {
			sb.append(" "+postData.get("city"));
		}
		if (postData.get("zip") != null) {
			sb.append(" "+postData.get("zip"));
		}
		String place = sb.toString();
		Position newPosition = getLocation(place);
		if (newPosition != null) {			
				position = newPosition;
				return true;
		}
		m_logger.error("Failed to get position for "+place);
		return false;
	}

	public String getID() {
		return id;
	}

	public Position getPosition() {
		return position;
	}

	public Address getAddress() {
		if (position != null) {
			return reverseGeocode(position, m_logger);
		}
		return null;
	}

	public String getImageName() {
		return imageName;
	}

	public String displayText() {
		StringBuilder sb = new StringBuilder(10);
		if (schedule != null) {
			sb.append(schedule.displayText());
		}
		if (position != null) {
			Address address = reverseGeocode(position, m_logger);
			sb.append(address.displayText());
		}
/*		
		if (address != null) {
			sb.append(address.displayText());
		}
*/		
		return sb.toString();
	}
/*
	public Direction getDirection() {
		return direction;
	}
*/
	public ParkingSchedule getParkingSchedule() {
		return schedule;
	}

	public ParkingSchedule getAutoSchedule() {
		return autoSchedule;
	}

	private  Position processSignImage(File signPicture) {
		return Exif.getPosition(signPicture);
		//
		// TODO: add algorithm to read parking schedule from image
		//
	}

	public static Position getLocation(String place) { // throws IOException {
		Geocoder geocoder = new Geocoder();
    	GeocoderRequest geocoderRequest = new GeocoderRequestBuilder().setAddress(place).getGeocoderRequest();
    	GeocodeResponse geocodeResponse = geocoder.geocode(geocoderRequest);

    	List<GeocoderResult> results = geocodeResponse.getResults();
    	if(results.size() >= 1) {
        	double lat = results.get(0).getGeometry().getLocation().getLat().doubleValue();
        	double lng = results.get(0).getGeometry().getLocation().getLng().doubleValue();
        	return new Position( lat, lng);
    	}
    	return null;
	}

	public static Address reverseGeocode(Position p, Logger logger) {
		try {	
			GeoApiContext context = new GeoApiContext().setApiKey("AIzaSyDni-ZQemF7eA1P-A76acHMF2tREyFM3HI");
			LatLng latLng = new LatLng(p.getLatitude(), p.getLongitude());
			GeocodingResult[] results = GeocodingApi.newRequest(context).latlng(latLng).await();
//			System.out.println(results[0].formattedAddress);
			return new Address(results[0].addressComponents, logger);
		}
		catch (Exception ex) {
			ex.printStackTrace();
		}
		return null;
	}

	public static String createRandom(int len) {
		final String alphabet = "0123456789ABCDE";
    	final int N = alphabet.length();

    	Random r = new Random();
    	StringBuilder sb = new StringBuilder(len);
    	for (int i = 0; i < len; i++) {
        	sb.append(alphabet.charAt(r.nextInt(N)));
    	}
    	return sb.toString();
	}

}